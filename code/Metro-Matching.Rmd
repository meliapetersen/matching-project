---
title: "Metro-Matching"
author: "Jaesa Rogers"
date: "8/22/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=F, warning=F )
```


```{r}
# need this installed to use
# genetic matching option in MatchIt
# install.packages("rgenoud")

# load package 
library( MatchIt )
library( here )
library( dplyr )

library( geojsonio )
library( sp )
```


## FIRST FUNCTION

```{r}

  ### dorling function

get_dorling <- function( cbsa )
{

   dorlings.url <- "https://raw.githubusercontent.com/meliapetersen/matching-project/master/data/cbsa-names-and-shapefiles.csv"
   dorlings <- read.csv( dorlings.url )

   file.name <- dorlings$shapefile[ dorlings$cbsa == cbsa ]
 

   base.url <- "https://raw.githubusercontent.com/DS4PS/usa-dorling-shapefiles/master/maps/metros-dorling/"

   full.url <- paste0( base.url, file.name )

   map <- geojsonio::geojson_read( x=full.url,  what="sp" )

   plot( map )

   return( map )
   
}

  
metro.cbsa <- 10580

dorling.object <- get_dorling(cbsa=metro.cbsa)


```


## SECOND FUNCTION



```{r}

### Rodeo data function 

rodeo_data <- function (df.treatment, df.census)
   {

df.treatment <- read.csv("rodeod-NMTC-data.csv")
df.census <- dorling.object@data

#df.census$GEOID <- as.numeric(as.character((df.census$GEOID)))

#merge leftjoin
df.rodeo <- merge(df.treatment, df.census, by.x="id2", by.y="GEOID", all.x=TRUE)

#transform dataframe into specific dataframe for cbsa called in first function
df.rodeo.metro <- filter (df.treatment, cbsa == metro.cbsa)

# omit NAs
row.names(df.rodeo.metro) <- df.rodeo.metro$id2    
df.rodeo.metro <- na.omit( df.rodeo.metro )

}

head(df.rodeo.metro)


<<<<<<< Updated upstream
```

```{r}
rodeo.metro <- rodeo_data()
=======
```{r}
rodeo.metro.i <- rodeo_data()
```

```{r}
head(rodeo.metro.i)

>>>>>>> Stashed changes
```


## SECOND FUNCTION

### matchit function 


**NOTE** the long output printed while the algorithm runs. Add code chunk option

results 


```{r}

<<<<<<< Updated upstream
build_matchit_metros <- function( df.rodeo.metro, m5 )

  {

   
   
# omit NAs
row.names(df.rodeo.metro) <- df.rodeo.metro$id2    
df.rodeo.metro <- na.omit( df.rodeo.metro )

# factor for called CBSA
# df.rodeo.metro$cbsa.f <- factor(df.rodeo.metro$cbsa)      


          
table( df.rodeo.metro$treatment )
=======
build_matchit_metros <- function(data = rodeo.metro.i)

  {


# factor for called CBSA
# df.rodeo.metro$cbsa.f <- factor(df.rodeo.metro$cbsa)      
# table( rodeo.metro$treatment )
>>>>>>> Stashed changes



# find matches in dataframe based on Household income, college education, and whiteness    
 m5 <- matchit( treatment ~ hinc12, 
               method="genetic", discard="both", reestimate=TRUE, 
<<<<<<< Updated upstream
               replace=FALSE, caliper=.25, data = df.rodeo.metro )
=======
               replace=FALSE, caliper=.25, data = rodeo.metro.i )
>>>>>>> Stashed changes



	}


```

```{r}
summary(m5)
```



# Run matchit_metro function

```{r}
matchit.object <- build_matchit_metros(data = rodeo.metro.i)
```



## THIRD FUNCTION

### Build dataframe vectors function

```{r}
# match matrix is the length of the original treated groups
# IDs are rows of the original dataset

build_color_vectors <- function(matchit.object)

{

matches <- data.frame( treatment.group.id=row.names( m5$match.matrix), 
                       control.group.id=m5$match.matrix )

these.na <- is.na(matches$control.group.id)

id.all.treated <- matches$treatment.group.id 
id.treated.matched <- matches$treatment.group.id[!these.na]
id.treated.unmatched <- matches$treatment.group.id[these.na]
id.control.matched <- na.omit(matches$control.group.id)
<<<<<<< Updated upstream
id.control.unmatched <- df.rodeo$id2 [ !(df.rodeo$id2 %in% id.all.treated | df.rodeo$id2 %in% id.control.matched)]
=======
id.control.unmatched <- rodeo.metro.i$id2 [ !(rodeo.metro.i$id2 %in% id.all.treated | rodeo.metro.i$id2 %in% id.control.matched)]
>>>>>>> Stashed changes

df.x <- data.frame(Fips = id.treated.matched, group = "treated", matched = TRUE)
df.x

# rowbind

matches <- na.omit(matches)

sum(is.na(matches$control.group.id))


m5$nn

# all treated cases in dataset:
length( m5$match.matrix )

# treated cases that were matched: 
sum( ! is.na(m5$match.matrix) )

### Extract balanced dataset 


new.dat <- match.data( m5 )
dim( new.dat ) # 2 x number in matched treatment group




### Create Treatment and Control vectors


treated.matched <- na.omit(id.treated.matched) %>% as.numeric
control.matched <- na.omit(id.control.matched) %>% as.numeric

treated.unmatched <- na.omit(id.treated.unmatched)  %>% as.numeric
control.unmatched <- na.omit(id.control.unmatched)  %>% as.numeric


### Create color vectors based on matches

color.vector <- rep( "gray", nrow(df) )
color.vector[ rodeo.metro.i$id2 %in% control.matched ] <- "blue"
color.vector[ rodeo.metro.i$id2 %in% treated.matched ] <- "darkred"
color.vector[ rodeo.metro.i$id2 %in% treated.unmatched ] <- adjustcolor( "darkred", alpha.f = 0.4 )


border.color <- rep( "gray40", nrow(df) )
border.color [ rodeo.metro.i$id2 %in% treated.unmatched ] <- "darkred"


}
```

```{r}
color.vector.object <- build_color_vectors()
```

## FOURTH FUNCTION

### Load dorling


```{r}

build_plot_function <- function(color.vector.object)

{


<<<<<<< Updated upstream

### Create color vectors based on matches

color.vector <- rep( "gray", nrow(df) )
color.vector[ df.rodeo.metro$id2 %in% control.matched ] <- "blue"
color.vector[ df.rodeo.metro$id2 %in% treated.matched ] <- "darkred"
color.vector[ df.rodeo.metro$id2 %in% treated.unmatched ] <- adjustcolor( "darkred", alpha.f = 0.4 )


border.color <- rep( "gray40", nrow(df) )
border.color [ df.rodeo.metro$id2 %in% treated.unmatched ] <- "darkred"

=======
>>>>>>> Stashed changes
lat <- rnorm(1000)
quantile( lat, c( 0.25, 0.75 ) )

# in the plot function
xlim=quantile( lat, c(0.25,0.75) )


par(mar=c(0,0,0,0))

plot(no, col= color.vector, border=border.color)

}

```

```{r}
plot_map <- build_plot_function()
```

